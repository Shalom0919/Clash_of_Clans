# 部落战争系统完整实现方案

## 一、系统架构

### 1.1 核心概念

```
部落战争 (Clan War) 流程:
1. 部落首领发起搜索 → 服务器匹配敌对部落
2. 匹配成功 → 通知双方所有成员
3. 部落成员选择敌方成员 → 发起讨伐
4. 战斗评分 → 星数优先，摧毁率次之
5. 同部落成员 → 可进入观战模式
6. 战斗结束 → 同步服务器，更新战争状态
```

### 1.2 数据结构设计

#### 服务器端新增结构

```cpp
// 部落战成员信息
struct ClanWarMember
{
    std::string memberId;
    std::string memberName;
    std::string mapData;           // 成员的基地数据
    int bestStars = 0;             // 被攻击的最高星数
    float bestDestructionRate = 0; // 被攻击的最高摧毁率
    std::vector<AttackRecord> attacksReceived; // 受到的攻击记录
};

// 攻击记录
struct AttackRecord
{
    std::string attackerId;
    std::string attackerName;
    int starsEarned = 0;
    float destructionRate = 0.0f;  // 0.0 ~ 1.0
    std::chrono::steady_clock::time_point attackTime;
};

// 部落战会话 (扩展)
struct ClanWarSession
{
    std::string warId;
    std::string clan1Id;
    std::string clan2Id;
    
    // 双方成员信息
    std::vector<ClanWarMember> clan1Members;
    std::vector<ClanWarMember> clan2Members;
    
    // 当前进行中的战斗
    std::map<std::string, PvpSession> activeBattles; // key: attackerId
    
    // 战争状态
    int clan1TotalStars = 0;
    int clan2TotalStars = 0;
    std::chrono::steady_clock::time_point startTime;
    std::chrono::steady_clock::time_point endTime;
    bool isActive = true;
};
```

#### 客户端新增协议

```cpp
enum PacketType
{
    // ... 现有协议 ...
    
    // 部落战争增强
    PACKET_CLAN_WAR_MEMBER_LIST = 50,   // 获取部落战成员列表
    PACKET_CLAN_WAR_ATTACK_START = 51,  // 开始攻击部落战目标
    PACKET_CLAN_WAR_ATTACK_END = 52,    // 部落战攻击结束
    PACKET_CLAN_WAR_SPECTATE = 53,      // 观战部落战
    PACKET_CLAN_WAR_STATE_UPDATE = 54   // 部落战状态更新
};
```

## 二、服务器端实现

### 2.1 Server.h 新增方法

```cpp
class Server
{
private:
    // 部落战争会话管理
    std::map<std::string, ClanWarSession> clanWarSessions; // warId -> ClanWarSession
    std::mutex clanWarSessionMutex;
    
    // 新增方法
    ClanWarSession* getClanWarSession(const std::string& warId);
    void initClanWarMembers(ClanWarSession& session);
    std::string getClanWarMemberListJson(const std::string& warId, const std::string& requesterId);
    void handleClanWarAttackStart(SOCKET clientSocket, const std::string& warId, const std::string& targetId);
    void handleClanWarAttackEnd(const std::string& warId, const AttackRecord& record);
    void handleClanWarSpectate(SOCKET clientSocket, const std::string& warId, const std::string& targetId);
    void broadcastClanWarStateUpdate(const std::string& warId);
};
```

### 2.2 核心逻辑实现

```cpp
// 初始化部落战成员信息
void Server::initClanWarMembers(ClanWarSession& session)
{
    std::lock_guard<std::mutex> lock(clanMutex);
    
    // 加载clan1成员
    if (clans.find(session.clan1Id) != clans.end())
    {
        for (const auto& memberId : clans[session.clan1Id].memberIds)
        {
            ClanWarMember member;
            member.memberId = memberId;
            
            SOCKET socket = findSocketByPlayerId(memberId);
            if (socket != INVALID_SOCKET)
            {
                member.memberName = onlinePlayers[socket].playerName;
            }
            
            // 加载地图数据
            if (savedMaps.find(memberId) != savedMaps.end())
            {
                member.mapData = savedMaps[memberId];
            }
            
            session.clan1Members.push_back(member);
        }
    }
    
    // 加载clan2成员（同上）
    // ... 类似逻辑 ...
}

// 获取部落战成员列表JSON
std::string Server::getClanWarMemberListJson(const std::string& warId, const std::string& requesterId)
{
    std::lock_guard<std::mutex> lock(clanWarSessionMutex);
    
    auto it = clanWarSessions.find(warId);
    if (it == clanWarSessions.end())
    {
        return "{}";
    }
    
    ClanWarSession& session = it->second;
    
    // 判断请求者所在部落
    std::string myClane = "";  // 请求者的部落
    std::string enemyClanId = "";  // 敌对部落
    
    SOCKET reqSocket = findSocketByPlayerId(requesterId);
    if (reqSocket != INVALID_SOCKET)
    {
        myClanId = onlinePlayers[reqSocket].clanId;
        enemyClanId = (myClanId == session.clan1Id) ? session.clan2Id : session.clan1Id;
    }
    
    // 构建JSON
    std::ostringstream oss;
    oss << "{"
        << "\"warId\":\"" << warId << "\","
        << "\"myClanId\":\"" << myClanId << "\","
        << "\"enemyClanId\":\"" << enemyClanId << "\","
        << "\"myMembers\":[";
    
    // 我方成员列表
    const auto& myMembers = (myClanId == session.clan1Id) ? session.clan1Members : session.clan2Members;
    for (size_t i = 0; i < myMembers.size(); ++i)
    {
        if (i > 0) oss << ",";
        oss << "{"
            << "\"id\":\"" << myMembers[i].memberId << "\","
            << "\"name\":\"" << myMembers[i].memberName << "\","
            << "\"bestStars\":" << myMembers[i].bestStars << ","
            << "\"bestDestruction\":" << myMembers[i].bestDestructionRate
            << "}";
    }
    oss << "],\"enemyMembers\":[";
    
    // 敌方成员列表
    const auto& enemyMembers = (enemyClanId == session.clan1Id) ? session.clan1Members : session.clan2Members;
    for (size_t i = 0; i < enemyMembers.size(); ++i)
    {
        if (i > 0) oss << ",";
        oss << "{"
            << "\"id\":\"" << enemyMembers[i].memberId << "\","
            << "\"name\":\"" << enemyMembers[i].memberName << "\","
            << "\"bestStars\":" << enemyMembers[i].bestStars << ","
            << "\"bestDestruction\":" << enemyMembers[i].bestDestructionRate << ","
            << "\"canAttack\":" << (enemyMembers[i].mapData.empty() ? "false" : "true")
            << "}";
    }
    oss << "]}";
    
    return oss.str();
}

// 处理部落战攻击开始
void Server::handleClanWarAttackStart(SOCKET clientSocket, const std::string& warId, const std::string& targetId)
{
    std::lock_guard<std::mutex> lock1(clanWarSessionMutex);
    std::lock_guard<std::mutex> lock2(pvpMutex);
    
    auto it = clanWarSessions.find(warId);
    if (it == clanWarSessions.end())
    {
        sendPacket(clientSocket, PACKET_CLAN_WAR_ATTACK_START, "FAIL|WAR_NOT_FOUND");
        return;
    }
    
    ClanWarSession& session = it->second;
    std::string attackerId = onlinePlayers[clientSocket].playerId;
    
    // 查找目标成员的地图数据
    std::string targetMapData = "";
    for (const auto& member : session.clan1Members)
    {
        if (member.memberId == targetId)
        {
            targetMapData = member.mapData;
            break;
        }
    }
    if (targetMapData.empty())
    {
        for (const auto& member : session.clan2Members)
        {
            if (member.memberId == targetId)
            {
                targetMapData = member.mapData;
                break;
            }
        }
    }
    
    if (targetMapData.empty())
    {
        sendPacket(clientSocket, PACKET_CLAN_WAR_ATTACK_START, "FAIL|NO_MAP");
        return;
    }
    
    // 创建PVP会话（复用现有PVP系统）
    PvpSession pvpSession;
    pvpSession.attackerId = attackerId;
    pvpSession.defenderId = targetId;
    pvpSession.mapData = targetMapData;
    
    // 保存到部落战会话
    session.activeBattles[attackerId] = pvpSession;
    
    // 通知攻击者
    sendPacket(clientSocket, PACKET_CLAN_WAR_ATTACK_START, "ATTACK|" + targetId + "|" + targetMapData);
    
    // 通知防御者（如果在线）
    SOCKET defenderSocket = findSocketByPlayerId(targetId);
    if (defenderSocket != INVALID_SOCKET)
    {
        sendPacket(defenderSocket, PACKET_PVP_START, "DEFEND|" + attackerId);
    }
    
    std::cout << "[ClanWar] " << warId << ": " << attackerId << " attacking " << targetId << std::endl;
}

// 处理部落战攻击结束
void Server::handleClanWarAttackEnd(const std::string& warId, const AttackRecord& record)
{
    std::lock_guard<std::mutex> lock(clanWarSessionMutex);
    
    auto it = clanWarSessions.find(warId);
    if (it == clanWarSessions.end())
        return;
    
    ClanWarSession& session = it->second;
    
    // 查找目标成员并更新最佳战绩
    auto updateMemberBest = [&](std::vector<ClanWarMember>& members, int& totalStars) {
        for (auto& member : members)
        {
            if (member.memberId == record.attackerId)
            {
                // 更新该成员的最佳成绩
                if (record.starsEarned > member.bestStars ||
                    (record.starsEarned == member.bestStars && record.destructionRate > member.bestDestructionRate))
                {
                    int starDiff = record.starsEarned - member.bestStars;
                    member.bestStars = record.starsEarned;
                    member.bestDestructionRate = record.destructionRate;
                    totalStars += starDiff;
                }
                member.attacksReceived.push_back(record);
                return true;
            }
        }
        return false;
    };
    
    // 尝试在clan1中查找
    if (!updateMemberBest(session.clan1Members, session.clan1TotalStars))
    {
        // 在clan2中查找
        updateMemberBest(session.clan2Members, session.clan2TotalStars);
    }
    
    // 清理PVP会话
    session.activeBattles.erase(record.attackerId);
    
    // 广播状态更新
    broadcastClanWarStateUpdate(warId);
}

// 广播部落战状态更新
void Server::broadcastClanWarStateUpdate(const std::string& warId)
{
    std::lock_guard<std::mutex> lock(clanWarSessionMutex);
    
    auto it = clanWarSessions.find(warId);
    if (it == clanWarSessions.end())
        return;
    
    ClanWarSession& session = it->second;
    
    // 构建状态JSON
    std::ostringstream oss;
    oss << "{"
        << "\"warId\":\"" << warId << "\","
        << "\"clan1Stars\":" << session.clan1TotalStars << ","
        << "\"clan2Stars\":" << session.clan2TotalStars
        << "}";
    
    std::string stateJson = oss.str();
    
    // 通知clan1所有成员
    if (clans.find(session.clan1Id) != clans.end())
    {
        for (const auto& memberId : clans[session.clan1Id].memberIds)
        {
            SOCKET socket = findSocketByPlayerId(memberId);
            if (socket != INVALID_SOCKET)
            {
                sendPacket(socket, PACKET_CLAN_WAR_STATE_UPDATE, stateJson);
            }
        }
    }
    
    // 通知clan2所有成员
    if (clans.find(session.clan2Id) != clans.end())
    {
        for (const auto& memberId : clans[session.clan2Id].memberIds)
        {
            SOCKET socket = findSocketByPlayerId(memberId);
            if (socket != INVALID_SOCKET)
            {
                sendPacket(socket, PACKET_CLAN_WAR_STATE_UPDATE, stateJson);
            }
        }
    }
}

// 处理部落战观战
void Server::handleClanWarSpectate(SOCKET clientSocket, const std::string& warId, const std::string& targetId)
{
    std::lock_guard<std::mutex> lock(clanWarSessionMutex);
    
    auto it = clanWarSessions.find(warId);
    if (it == clanWarSessions.end())
    {
        sendPacket(clientSocket, PACKET_CLAN_WAR_SPECTATE, "FAIL|WAR_NOT_FOUND");
        return;
    }
    
    ClanWarSession& session = it->second;
    std::string spectatorId = onlinePlayers[clientSocket].playerId;
    
    // 查找目标正在进行的战斗
    for (auto& [attackerId, pvpSession] : session.activeBattles)
    {
        if (attackerId == targetId || pvpSession.defenderId == targetId)
        {
            // 加入观战列表
            pvpSession.spectatorIds.push_back(spectatorId);
            
            // 通知观战者
            std::string response = "SPECTATE|" + attackerId + "|" + pvpSession.defenderId + "|" + pvpSession.mapData;
            sendPacket(clientSocket, PACKET_CLAN_WAR_SPECTATE, response);
            
            std::cout << "[ClanWar] " << spectatorId << " spectating " << attackerId << " vs " << pvpSession.defenderId << std::endl;
            return;
        }
    }
    
    // 目标没有在战斗中
    sendPacket(clientSocket, PACKET_CLAN_WAR_SPECTATE, "FAIL|NOT_IN_BATTLE");
}
```

### 2.3 客户端消息处理增强

```cpp
// 在 clientHandler() 中添加

case PACKET_CLAN_WAR_MEMBER_LIST:
{
    std::string warId = msgData;
    std::string requesterId = server.onlinePlayers[clientSocket].playerId;
    std::string memberListJson = server.getClanWarMemberListJson(warId, requesterId);
    Server::sendPacket(clientSocket, PACKET_CLAN_WAR_MEMBER_LIST, memberListJson);
}
break;

case PACKET_CLAN_WAR_ATTACK_START:
{
    // 格式: warId|targetId
    std::istringstream iss(msgData);
    std::string warId, targetId;
    std::getline(iss, warId, '|');
    std::getline(iss, targetId);
    
    server.handleClanWarAttackStart(clientSocket, warId, targetId);
}
break;

case PACKET_CLAN_WAR_ATTACK_END:
{
    // 格式: warId|attackRecord
    size_t pos = msgData.find('|');
    if (pos != std::string::npos)
    {
        std::string warId = msgData.substr(0, pos);
        std::string recordData = msgData.substr(pos + 1);
        
        // 解析AttackRecord（需要扩展deserialize支持destructionRate）
        AttackRecord record;
        std::istringstream iss(recordData);
        std::string token;
        std::getline(iss, record.attackerId, '|');
        std::getline(iss, record.attackerName, '|');
        std::getline(iss, token, '|');
        record.starsEarned = std::stoi(token);
        std::getline(iss, token, '|');
        record.destructionRate = std::stof(token);
        
        server.handleClanWarAttackEnd(warId, record);
    }
}
break;

case PACKET_CLAN_WAR_SPECTATE:
{
    // 格式: warId|targetId
    std::istringstream iss(msgData);
    std::string warId, targetId;
    std::getline(iss, warId, '|');
    std::getline(iss, targetId);
    
    server.handleClanWarSpectate(clientSocket, warId, targetId);
}
break;
```

## 三、客户端实现

### 3.1 SocketClient 新增方法

```cpp
// SocketClient.h
class SocketClient
{
public:
    // 部落战争相关
    void requestClanWarMemberList(const std::string& warId);
    void startClanWarAttack(const std::string& warId, const std::string& targetId);
    void endClanWarAttack(const std::string& warId, int stars, float destructionRate);
    void spectateClanWar(const std::string& warId, const std::string& targetId);
    
    // 回调设置
    void setOnClanWarMemberList(std::function<void(const std::string&)> callback);
    void setOnClanWarAttackStart(std::function<void(const std::string&, const std::string&, const std::string&)> callback);
    void setOnClanWarSpectate(std::function<void(bool, const std::string&, const std::string&, const std::string&)> callback);
    void setOnClanWarStateUpdate(std::function<void(const std::string&)> callback);
    
private:
    std::function<void(const std::string&)> _onClanWarMemberList;
    std::function<void(const std::string&, const std::string&, const std::string&)> _onClanWarAttackStart;
    std::function<void(bool, const std::string&, const std::string&, const std::string&)> _onClanWarSpectate;
    std::function<void(const std::string&)> _onClanWarStateUpdate;
};

// SocketClient.cpp 实现
void SocketClient::requestClanWarMemberList(const std::string& warId)
{
    sendPacket(PACKET_CLAN_WAR_MEMBER_LIST, warId);
}

void SocketClient::startClanWarAttack(const std::string& warId, const std::string& targetId)
{
    std::string data = warId + "|" + targetId;
    sendPacket(PACKET_CLAN_WAR_ATTACK_START, data);
}

void SocketClient::endClanWarAttack(const std::string& warId, int stars, float destructionRate)
{
    auto& accMgr = AccountManager::getInstance();
    std::string attackerId = accMgr.getCurrentAccount()->userId;
    std::string attackerName = accMgr.getCurrentAccount()->username;
    
    std::ostringstream oss;
    oss << warId << "|" 
        << attackerId << "|"
        << attackerName << "|"
        << stars << "|"
        << destructionRate;
    
    sendPacket(PACKET_CLAN_WAR_ATTACK_END, oss.str());
}

void SocketClient::spectateClanWar(const std::string& warId, const std::string& targetId)
{
    std::string data = warId + "|" + targetId;
    sendPacket(PACKET_CLAN_WAR_SPECTATE, data);
}

// handlePacket 中添加
case PACKET_CLAN_WAR_MEMBER_LIST:
    if (_onClanWarMemberList)
        _onClanWarMemberList(data);
    break;

case PACKET_CLAN_WAR_ATTACK_START:
{
    if (_onClanWarAttackStart)
    {
        std::istringstream iss(data);
        std::string type, targetId, mapData;
        std::getline(iss, type, '|');
        std::getline(iss, targetId, '|');
        std::getline(iss, mapData);
        _onClanWarAttackStart(type, targetId, mapData);
    }
}
break;

case PACKET_CLAN_WAR_SPECTATE:
{
    if (_onClanWarSpectate)
    {
        if (data.substr(0, 4) == "FAIL")
        {
            _onClanWarSpectate(false, "", "", "");
        }
        else
        {
            std::istringstream iss(data);
            std::string type, attackerId, defenderId, mapData;
            std::getline(iss, type, '|');
            std::getline(iss, attackerId, '|');
            std::getline(iss, defenderId, '|');
            std::getline(iss, mapData);
            _onClanWarSpectate(true, attackerId, defenderId, mapData);
        }
    }
}
break;

case PACKET_CLAN_WAR_STATE_UPDATE:
    if (_onClanWarStateUpdate)
        _onClanWarStateUpdate(data);
    break;
```

### 3.2 ClanPanel 完善部落战标签页

由于代码过长，我将在下一步继续实现客户端UI部分。

## 四、战斗逻辑修正

### 4.1 BattleManager 模式扩展

```cpp
// BattleManager.h
enum class BattleMode
{
    LOCAL,          // 本地测试
    PVP_ATTACK,     // PVP攻击
    PVP_DEFEND,     // PVP防守
    CLAN_WAR_ATTACK,   // 部落战攻击
    CLAN_WAR_DEFEND,   // 部落战防守
    SPECTATE        // 观战模式
};

class BattleManager
{
private:
    BattleMode _battleMode = BattleMode::LOCAL;
    std::string _currentWarId;  // 当前部落战ID
    
public:
    void setBattleMode(BattleMode mode, const std::string& warId = "");
    bool canDeployUnit() const;  // 根据模式判断能否下兵
};

// 实现
bool BattleManager::canDeployUnit() const
{
    switch (_battleMode)
    {
    case BattleMode::LOCAL:
    case BattleMode::PVP_ATTACK:
    case BattleMode::CLAN_WAR_ATTACK:
        return true;
    case BattleMode::PVP_DEFEND:
    case BattleMode::CLAN_WAR_DEFEND:
    case BattleMode::SPECTATE:
        return false;
    }
    return false;
}
```

### 4.2 部落战结束逻辑

```cpp
// BattleManager::onBattleEnd()
void BattleManager::onBattleEnd()
{
    if (_battleMode == BattleMode::CLAN_WAR_ATTACK)
    {
        // 计算星数和摧毁率
        int stars = calculateStars();
        float destructionRate = calculateDestructionRate();
        
        // 上报服务器
        SocketClient::getInstance().endClanWarAttack(_currentWarId, stars, destructionRate);
        
        // 显示结果
        showBattleResult(stars, destructionRate);
    }
}

int BattleManager::calculateStars() const
{
    int stars = 0;
    
    // 摧毁大本营 = 1星
    if (isTownHallDestroyed())
        stars++;
    
    // 摧毁50% = 1星
    if (getDestructionRate() >= 0.5f)
        stars++;
    
    // 全部摧毁 = 1星
    if (getDestructionRate() >= 1.0f)
        stars++;
    
    return stars;
}

float BattleManager::calculateDestructionRate() const
{
    int totalBuildings = _allBuildings.size();
    int destroyedBuildings = 0;
    
    for (auto* building : _allBuildings)
    {
        if (building->getHP() <= 0)
            destroyedBuildings++;
    }
    
    return totalBuildings > 0 ? (float)destroyedBuildings / totalBuildings : 0.0f;
}
```

## 五、测试流程

### 5.1 测试步骤

1. **创建部落**
   - 玩家A创建部落"Clan A"
   - 玩家B创建部落"Clan B"

2. **发起部落战**
   - Clan A首领搜索部落战
   - Clan B首领搜索部落战
   - 服务器自动匹配

3. **查看成员列表**
   - 打开部落战标签页
   - 显示敌方成员列表

4. **发起讨伐**
   - 选择敌方成员
   - 点击"攻击"按钮
   - 进入战斗场景

5. **同部落观战**
   - Clan A的其他成员
   - 点击"观战"按钮
   - 实时查看战斗

6. **战斗结束**
   - 计算星数和摧毁率
   - 同步服务器
   - 更新战争状态

### 5.2 预期结果

- ? 部落战搜索成功匹配
- ? 成员列表正确显示
- ? 可以正常下兵作战
- ? 观战模式实时同步
- ? 星数和摧毁率正确计算
- ? 战争状态实时更新

## 六、注意事项

1. **线程安全** - 所有共享数据访问使用mutex保护
2. **内存管理** - PVP会话结束后及时清理
3. **网络断线** - 战斗中断线需要处理重连逻辑
4. **作弊防护** - 客户端数据需要服务器验证
5. **性能优化** - 大规模部落战时注意消息广播效率

## 七、后续扩展

1. **战争时长限制** - 24小时自动结束
2. **攻击次数限制** - 每人限制攻击次数
3. **战争奖励** - 胜利方获得资源奖励
4. **战争历史** - 保存历史记录供查看
5. **战争回放** - 支持战斗录像回放

---

**实现优先级**：
1. ? 服务器端部落战会话管理
2. ? 客户端网络协议扩展
3. ? ClanPanel UI完善
4. ? BattleManager模式扩展
5. ? 测试验证

该方案已涵盖所有核心功能，可以分步实施。
