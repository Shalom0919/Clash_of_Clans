# 部落战争系统实施指南

## 完成状态

### ? 已完成
1. Server.h - 添加新数据结构（ClanWarSession, ClanWarMember, AttackRecord）
2. Server.h - 添加新消息类型（PACKET_CLAN_WAR_*系列，50-54）
3. Server.h - 添加部落战管理方法声明

### ? 待实施（按优先级）

## 一、服务器端实现（高优先级）

### 1. Server.cpp - 添加部落战逻辑实现

在`Server.cpp`末尾添加以下方法实现：

```cpp
//==================== 部落战争增强实现 ====================

ClanWarSession* Server::getClanWarSession(const std::string& warId)
{
    auto it = clanWarSessions.find(warId);
    return (it != clanWarSessions.end()) ? &it->second : nullptr;
}

void Server::initClanWarMembers(ClanWarSession& session)
{
    std::lock_guard<std::mutex> lock(clanMutex);
    
    // 加载clan1成员
    if (clans.find(session.clan1Id) != clans.end())
    {
        for (const auto& memberId : clans[session.clan1Id].memberIds)
        {
            ClanWarMember member;
            member.memberId = memberId;
            
            SOCKET socket = findSocketByPlayerId(memberId);
            if (socket != INVALID_SOCKET)
            {
                member.memberName = onlinePlayers[socket].playerName;
            }
            else
            {
                member.memberName = memberId; // 离线玩家使用ID作为名称
            }
            
            // 加载地图数据
            if (savedMaps.find(memberId) != savedMaps.end())
            {
                member.mapData = savedMaps[memberId];
            }
            
            session.clan1Members.push_back(member);
        }
    }
    
    // 加载clan2成员
    if (clans.find(session.clan2Id) != clans.end())
    {
        for (const auto& memberId : clans[session.clan2Id].memberIds)
        {
            ClanWarMember member;
            member.memberId = memberId;
            
            SOCKET socket = findSocketByPlayerId(memberId);
            if (socket != INVALID_SOCKET)
            {
                member.memberName = onlinePlayers[socket].playerName;
            }
            else
            {
                member.memberName = memberId;
            }
            
            if (savedMaps.find(memberId) != savedMaps.end())
            {
                member.mapData = savedMaps[memberId];
            }
            
            session.clan2Members.push_back(member);
        }
    }
}

std::string Server::getClanWarMemberListJson(const std::string& warId, const std::string& requesterId)
{
    std::lock_guard<std::mutex> lock(clanWarSessionMutex);
    
    auto it = clanWarSessions.find(warId);
    if (it == clanWarSessions.end())
    {
        return "{\"error\":\"WAR_NOT_FOUND\"}";
    }
    
    ClanWarSession& session = it->second;
    
    // 判断请求者所在部落
    std::string myClanId = "";
    std::string enemyClanId = "";
    
    SOCKET reqSocket = findSocketByPlayerId(requesterId);
    if (reqSocket != INVALID_SOCKET)
    {
        myClanId = onlinePlayers[reqSocket].clanId;
        enemyClanId = (myClanId == session.clan1Id) ? session.clan2Id : session.clan1Id;
    }
    
    // 构建JSON
    std::ostringstream oss;
    oss << "{"
        << "\"warId\":\"" << warId << "\","
        << "\"myClanId\":\"" << myClanId << "\","
        << "\"enemyClanId\":\"" << enemyClanId << "\","
        << "\"clan1TotalStars\":" << session.clan1TotalStars << ","
        << "\"clan2TotalStars\":" << session.clan2TotalStars << ","
        << "\"myMembers\":[";
    
    // 我方成员列表
    const auto& myMembers = (myClanId == session.clan1Id) ? session.clan1Members : session.clan2Members;
    for (size_t i = 0; i < myMembers.size(); ++i)
    {
        if (i > 0) oss << ",";
        oss << "{"
            << "\"id\":\"" << myMembers[i].memberId << "\","
            << "\"name\":\"" << myMembers[i].memberName << "\","
            << "\"bestStars\":" << myMembers[i].bestStars << ","
            << "\"bestDestruction\":" << myMembers[i].bestDestructionRate
            << "}";
    }
    oss << "],\"enemyMembers\":[";
    
    // 敌方成员列表
    const auto& enemyMembers = (enemyClanId == session.clan1Id) ? session.clan1Members : session.clan2Members;
    for (size_t i = 0; i < enemyMembers.size(); ++i)
    {
        if (i > 0) oss << ",";
        oss << "{"
            << "\"id\":\"" << enemyMembers[i].memberId << "\","
            << "\"name\":\"" << enemyMembers[i].memberName << "\","
            << "\"bestStars\":" << enemyMembers[i].bestStars << ","
            << "\"bestDestruction\":" << enemyMembers[i].bestDestructionRate << ","
            << "\"canAttack\":" << (enemyMembers[i].mapData.empty() ? "false" : "true")
            << "}";
    }
    oss << "]}";
    
    return oss.str();
}

void Server::handleClanWarAttackStart(SOCKET clientSocket, const std::string& warId, const std::string& targetId)
{
    std::lock_guard<std::mutex> lock1(clanWarSessionMutex);
    std::lock_guard<std::mutex> lock2(dataMutex);
    
    auto it = clanWarSessions.find(warId);
    if (it == clanWarSessions.end())
    {
        sendPacket(clientSocket, PACKET_CLAN_WAR_ATTACK_START, "FAIL|WAR_NOT_FOUND");
        return;
    }
    
    ClanWarSession& session = it->second;
    std::string attackerId = onlinePlayers[clientSocket].playerId;
    
    // 查找目标成员的地图数据
    std::string targetMapData = "";
    for (const auto& member : session.clan1Members)
    {
        if (member.memberId == targetId)
        {
            targetMapData = member.mapData;
            break;
        }
    }
    if (targetMapData.empty())
    {
        for (const auto& member : session.clan2Members)
        {
            if (member.memberId == targetId)
            {
                targetMapData = member.mapData;
                break;
            }
        }
    }
    
    if (targetMapData.empty())
    {
        sendPacket(clientSocket, PACKET_CLAN_WAR_ATTACK_START, "FAIL|NO_MAP");
        return;
    }
    
    // 创建PVP会话
    PvpSession pvpSession;
    pvpSession.attackerId = attackerId;
    pvpSession.defenderId = targetId;
    pvpSession.mapData = targetMapData;
    
    // 保存到部落战会话
    session.activeBattles[attackerId] = pvpSession;
    
    // 通知攻击者
    sendPacket(clientSocket, PACKET_CLAN_WAR_ATTACK_START, "ATTACK|" + targetId + "|" + targetMapData);
    
    // 通知防御者（如果在线）
    SOCKET defenderSocket = findSocketByPlayerId(targetId);
    if (defenderSocket != INVALID_SOCKET)
    {
        sendPacket(defenderSocket, PACKET_PVP_START, "DEFEND|" + attackerId);
    }
    
    std::cout << "[ClanWar] " << warId << ": " << attackerId << " attacking " << targetId << std::endl;
}

void Server::handleClanWarAttackEnd(const std::string& warId, const AttackRecord& record)
{
    std::lock_guard<std::mutex> lock(clanWarSessionMutex);
    
    auto it = clanWarSessions.find(warId);
    if (it == clanWarSessions.end())
        return;
    
    ClanWarSession& session = it->second;
    
    // 查找并更新被攻击成员的最佳战绩
    auto updateMemberBest = [&](std::vector<ClanWarMember>& members, int& totalStars) {
        for (auto& member : members)
        {
            if (member.memberId == record.attackerId) // 这里应该是defenderId!
            {
                // 更新该成员的最佳成绩
                if (record.starsEarned > member.bestStars ||
                    (record.starsEarned == member.bestStars && record.destructionRate > member.bestDestructionRate))
                {
                    int starDiff = record.starsEarned - member.bestStars;
                    member.bestStars = record.starsEarned;
                    member.bestDestructionRate = record.destructionRate;
                    totalStars += starDiff;
                }
                member.attacksReceived.push_back(record);
                return true;
            }
        }
        return false;
    };
    
    // 注意：record.attackerId 是攻击者，我们需要找到被攻击者（defenderId）
    // 这里需要从activeBattles中找到对应的defenderId
    auto battleIt = session.activeBattles.find(record.attackerId);
    if (battleIt != session.activeBattles.end())
    {
        std::string defenderId = battleIt->second.defenderId;
        
        // 创建修正后的记录
        AttackRecord correctedRecord = record;
        // 实际上我们需要更新defenderId对应的成员
        
        // 尝试在clan1中查找defenderId
        bool found = false;
        for (auto& member : session.clan1Members)
        {
            if (member.memberId == defenderId)
            {
                if (record.starsEarned > member.bestStars ||
                    (record.starsEarned == member.bestStars && record.destructionRate > member.bestDestructionRate))
                {
                    int starDiff = record.starsEarned - member.bestStars;
                    member.bestStars = record.starsEarned;
                    member.bestDestructionRate = record.destructionRate;
                    // 攻击者是clan2，所以给clan2加星
                    session.clan2TotalStars += starDiff;
                }
                member.attacksReceived.push_back(record);
                found = true;
                break;
            }
        }
        
        if (!found)
        {
            // 在clan2中查找
            for (auto& member : session.clan2Members)
            {
                if (member.memberId == defenderId)
                {
                    if (record.starsEarned > member.bestStars ||
                        (record.starsEarned == member.bestStars && record.destructionRate > member.bestDestructionRate))
                    {
                        int starDiff = record.starsEarned - member.bestStars;
                        member.bestStars = record.starsEarned;
                        member.bestDestructionRate = record.destructionRate;
                        // 攻击者是clan1，所以给clan1加星
                        session.clan1TotalStars += starDiff;
                    }
                    member.attacksReceived.push_back(record);
                    break;
                }
            }
        }
        
        // 清理PVP会话
        session.activeBattles.erase(record.attackerId);
    }
    
    // 广播状态更新
    broadcastClanWarStateUpdate(warId);
}

void Server::broadcastClanWarStateUpdate(const std::string& warId)
{
    std::lock_guard<std::mutex> lock1(clanWarSessionMutex);
    std::lock_guard<std::mutex> lock2(clanMutex);
    
    auto it = clanWarSessions.find(warId);
    if (it == clanWarSessions.end())
        return;
    
    ClanWarSession& session = it->second;
    
    // 构建状态JSON
    std::ostringstream oss;
    oss << "{"
        << "\"warId\":\"" << warId << "\","
        << "\"clan1Stars\":" << session.clan1TotalStars << ","
        << "\"clan2Stars\":" << session.clan2TotalStars
        << "}";
    
    std::string stateJson = oss.str();
    
    // 通知clan1所有成员
    if (clans.find(session.clan1Id) != clans.end())
    {
        for (const auto& memberId : clans[session.clan1Id].memberIds)
        {
            SOCKET socket = findSocketByPlayerId(memberId);
            if (socket != INVALID_SOCKET)
            {
                sendPacket(socket, PACKET_CLAN_WAR_STATE_UPDATE, stateJson);
            }
        }
    }
    
    // 通知clan2所有成员
    if (clans.find(session.clan2Id) != clans.end())
    {
        for (const auto& memberId : clans[session.clan2Id].memberIds)
        {
            SOCKET socket = findSocketByPlayerId(memberId);
            if (socket != INVALID_SOCKET)
            {
                sendPacket(socket, PACKET_CLAN_WAR_STATE_UPDATE, stateJson);
            }
        }
    }
}

void Server::handleClanWarSpectate(SOCKET clientSocket, const std::string& warId, const std::string& targetId)
{
    std::lock_guard<std::mutex> lock1(clanWarSessionMutex);
    std::lock_guard<std::mutex> lock2(dataMutex);
    
    auto it = clanWarSessions.find(warId);
    if (it == clanWarSessions.end())
    {
        sendPacket(clientSocket, PACKET_CLAN_WAR_SPECTATE, "FAIL|WAR_NOT_FOUND");
        return;
    }
    
    ClanWarSession& session = it->second;
    std::string spectatorId = onlinePlayers[clientSocket].playerId;
    
    // 查找目标正在进行的战斗
    for (auto& [attackerId, pvpSession] : session.activeBattles)
    {
        if (attackerId == targetId || pvpSession.defenderId == targetId)
        {
            // 加入观战列表
            pvpSession.spectatorIds.push_back(spectatorId);
            
            // 通知观战者
            std::string response = "SPECTATE|" + attackerId + "|" + pvpSession.defenderId + "|" + pvpSession.mapData;
            sendPacket(clientSocket, PACKET_CLAN_WAR_SPECTATE, response);
            
            std::cout << "[ClanWar] " << spectatorId << " spectating " << attackerId << " vs " << pvpSession.defenderId << std::endl;
            return;
        }
    }
    
    // 目标没有在战斗中
    sendPacket(clientSocket, PACKET_CLAN_WAR_SPECTATE, "FAIL|NOT_IN_BATTLE");
}
```

### 2. Server.cpp - 修改startClanWar方法

找到`void Server::startClanWar(...)`方法，在创建`ClanWarInfo`后添加：

```cpp
void Server::startClanWar(const std::string& clan1Id, const std::string& clan2Id)
{
    // ... 现有代码 ...
    
    activeWars[war.warId] = war;
    
    // ?? 创建部落战会话
    {
        std::lock_guard<std::mutex> lock(clanWarSessionMutex);
        ClanWarSession session;
        session.warId = war.warId;
        session.clan1Id = clan1Id;
        session.clan2Id = clan2Id;
        session.startTime = war.startTime;
        session.endTime = war.endTime;
        session.isActive = true;
        
        // 初始化成员信息
        initClanWarMembers(session);
        
        clanWarSessions[war.warId] = session;
        
        std::cout << "[ClanWar] Session created: " << war.warId 
                  << " (Clan1: " << session.clan1Members.size() << " members, "
                  << "Clan2: " << session.clan2Members.size() << " members)" << std::endl;
    }
    
    // 通知两个部落的所有在线成员
    // ... 现有代码 ...
}
```

### 3. Server.cpp - clientHandler中添加新消息处理

在`clientHandler()`函数的switch语句中添加：

```cpp
case PACKET_CLAN_WAR_MEMBER_LIST:
{
    std::string warId = msgData;
    std::string requesterId = server.onlinePlayers[clientSocket].playerId;
    std::string memberListJson = server.getClanWarMemberListJson(warId, requesterId);
    Server::sendPacket(clientSocket, PACKET_CLAN_WAR_MEMBER_LIST, memberListJson);
}
break;

case PACKET_CLAN_WAR_ATTACK_START:
{
    // 格式: warId|targetId
    std::istringstream iss(msgData);
    std::string warId, targetId;
    std::getline(iss, warId, '|');
    std::getline(iss, targetId);
    
    server.handleClanWarAttackStart(clientSocket, warId, targetId);
}
break;

case PACKET_CLAN_WAR_ATTACK_END:
{
    // 格式: warId|attackerId|attackerName|stars|destructionRate
    std::istringstream iss(msgData);
    std::string warId, attackerId, attackerName, starsStr, destructionStr;
    std::getline(iss, warId, '|');
    std::getline(iss, attackerId, '|');
    std::getline(iss, attackerName, '|');
    std::getline(iss, starsStr, '|');
    std::getline(iss, destructionStr);
    
    AttackRecord record;
    record.attackerId = attackerId;
    record.attackerName = attackerName;
    record.starsEarned = std::stoi(starsStr);
    record.destructionRate = std::stof(destructionStr);
    record.attackTime = std::chrono::steady_clock::now();
    
    server.handleClanWarAttackEnd(warId, record);
}
break;

case PACKET_CLAN_WAR_SPECTATE:
{
    // 格式: warId|targetId
    std::istringstream iss(msgData);
    std::string warId, targetId;
    std::getline(iss, warId, '|');
    std::getline(iss, targetId);
    
    server.handleClanWarSpectate(clientSocket, warId, targetId);
}
break;
```

## 二、客户端实现（中优先级）

### 1. SocketClient.h - 添加方法声明

在`SocketClient`类中添加：

```cpp
public:
    // 部落战争相关
    void requestClanWarMemberList(const std::string& warId);
    void startClanWarAttack(const std::string& warId, const std::string& targetId);
    void endClanWarAttack(const std::string& warId, int stars, float destructionRate);
    void spectateClanWar(const std::string& warId, const std::string& targetId);
    
    // 回调设置
    void setOnClanWarMemberList(std::function<void(const std::string&)> callback);
    void setOnClanWarAttackStart(std::function<void(const std::string&, const std::string&, const std::string&)> callback);
    void setOnClanWarSpectate(std::function<void(bool, const std::string&, const std::string&, const std::string&)> callback);
    void setOnClanWarStateUpdate(std::function<void(const std::string&)> callback);

private:
    // 回调函数
    std::function<void(const std::string&)> _onClanWarMemberList;
    std::function<void(const std::string&, const std::string&, const std::string&)> _onClanWarAttackStart;
    std::function<void(bool, const std::string&, const std::string&, const std::string&)> _onClanWarSpectate;
    std::function<void(const std::string&)> _onClanWarStateUpdate;
```

### 2. SocketClient.cpp - 实现方法

添加实现（代码见实施方案文档）

### 3. ClanPanel - 完善部落战标签页

修改`requestClanWarInfo()`方法：

```cpp
void ClanPanel::requestClanWarInfo()
{
    // 获取当前部落的部落战状态
    auto& accMgr = AccountManager::getInstance();
    auto currentAccount = accMgr.getCurrentAccount();
    
    if (!currentAccount || currentAccount->clanId.empty())
    {
        _memberList->removeAllItems();
        auto infoLabel = Label::createWithSystemFont("请先加入部落", "Arial", 24);
        infoLabel->setTextColor(Color4B::YELLOW);
        auto item = Layout::create();
        item->setContentSize(Size(560, 100));
        item->addChild(infoLabel);
        infoLabel->setPosition(Vec2(280, 50));
        _memberList->pushBackCustomItem(item);
        return;
    }
    
    // 请求部落战成员列表（需要先有warId）
    // 这里需要从服务器获取当前部落的warId
    // 暂时先显示提示
    _memberList->removeAllItems();
    auto infoLabel = Label::createWithSystemFont("正在获取部落战信息...", "Arial", 24);
    infoLabel->setTextColor(Color4B::YELLOW);
    auto item = Layout::create();
    item->setContentSize(Size(560, 100));
    item->addChild(infoLabel);
    infoLabel->setPosition(Vec2(280, 50));
    _memberList->pushBackCustomItem(item);
    
    // TODO: 实际请求部落战成员列表
    // SocketClient::getInstance().requestClanWarMemberList(warId);
}
```

## 三、BattleManager扩展（中优先级）

### 1. BattleManager.h - 添加模式枚举

```cpp
enum class BattleMode
{
    LOCAL,              // 本地测试
    PVP_ATTACK,         // PVP攻击
    PVP_DEFEND,         // PVP防守
    CLAN_WAR_ATTACK,    // 部落战攻击
    CLAN_WAR_DEFEND,    // 部落战防守
    SPECTATE            // 观战模式
};

class BattleManager
{
private:
    BattleMode _battleMode = BattleMode::LOCAL;
    std::string _currentWarId;
    
public:
    void setBattleMode(BattleMode mode, const std::string& warId = "");
    bool canDeployUnit() const;
    int calculateStars() const;
    float calculateDestructionRate() const;
};
```

### 2. BattleManager.cpp - 实现

```cpp
void BattleManager::setBattleMode(BattleMode mode, const std::string& warId)
{
    _battleMode = mode;
    _currentWarId = warId;
}

bool BattleManager::canDeployUnit() const
{
    switch (_battleMode)
    {
    case BattleMode::LOCAL:
    case BattleMode::PVP_ATTACK:
    case BattleMode::CLAN_WAR_ATTACK:
        return true;
    case BattleMode::PVP_DEFEND:
    case BattleMode::CLAN_WAR_DEFEND:
    case BattleMode::SPECTATE:
        return false;
    }
    return false;
}

int BattleManager::calculateStars() const
{
    int stars = 0;
    
    if (isTownHallDestroyed())
        stars++;
    
    float destruction = calculateDestructionRate();
    if (destruction >= 0.5f)
        stars++;
    
    if (destruction >= 1.0f)
        stars++;
    
    return stars;
}

float BattleManager::calculateDestructionRate() const
{
    int totalBuildings = _defenseBuildings.size();
    int destroyedBuildings = 0;
    
    for (auto* building : _defenseBuildings)
    {
        if (building && building->getHP() <= 0)
            destroyedBuildings++;
    }
    
    return totalBuildings > 0 ? (float)destroyedBuildings / totalBuildings : 0.0f;
}
```

## 四、测试流程

1. ? 编译服务器（已通过）
2. ? 编译客户端
3. ? 测试部落创建和搜索匹配
4. ? 测试部落战成员列表获取
5. ? 测试发起攻击和观战
6. ? 测试战斗结束和星数计算

## 注意事项

1. **线程安全** - 所有对clanWarSessions的访问都需要clanWarSessionMutex保护
2. **数据同步** - 确保客户端和服务器的战斗状态一致
3. **内存管理** - PVP会话结束后及时清理
4. **错误处理** - 所有网络请求都需要错误处理
5. **UI反馈** - 用户操作需要及时反馈

## 后续优化

1. 添加战争时长限制（24小时）
2. 添加攻击次数限制
3. 添加战争奖励系统
4. 保存战争历史记录
5. 实现战斗回放功能

---

**当前进度：25%**
- ? 服务器端数据结构设计完成
- ? 服务器端逻辑实现中
- ? 客户端SocketClient扩展待实施
- ? 客户端UI完善待实施
- ? BattleManager扩展待实施
- ? 测试验证待进行

建议按照本文档逐步实施，每完成一个模块后进行编译测试，确保没有引入错误。
